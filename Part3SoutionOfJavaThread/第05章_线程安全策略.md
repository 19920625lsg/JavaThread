# 第05章 线程安全策略

## 5.1~5.2 不可变对象

### 不可变对象需要满足的条件

+ 对象创建后其状态就不能修改
+ 对象所有域都是final类型
+ 对象是正确创建地(在对象创建期间，this引用没有逸出)

### final关键字

> 可以修饰类、方法和变量

+ 修饰类：不能被继承
+ 修饰方法：
  + 1.锁定方法不能被继承类修改
  + 2.效率高
+ 修饰变量：
  + 1.基本数据类型：数值一旦初始化后便不能修改了
  + 2.引用类型变量：初始化后就不能指向另外一个对象了
+ 修饰方法参数：通修饰变量

### 创建不可变对象的方式(参考String)

+ 将类声明称final类型，使其不可以被继承
+ 将所有的成员设置成私有的，使其他的类和对象不能直接访问这些成员
+ 对变量不提供set方法
+ 将所有可变的成员声明为final，这样只能对他们赋值一次
+ 通过构造器初始化所有成员，进行深度拷贝
+ 在get方法中，不直接返回对象本身，而是克隆对象，返回对象的拷贝

### 使用工具类来完成不可变对象的创建

+ `Collections.unmodifiableXXX`：Collection、List、Set、Map...
+ `Guava`：ImmutableXXX：Collection、List、Set、Map...

```java
@Slf4j
public class ImmutableExample2 {

    private static Map<Integer, Integer> map = Maps.newHashMap();

    static {
        map.put(1, 2);
        // 转换成不可变对象
        map = Collections.unmodifiableMap(map);
    }

    public static void main(String[] args) {
        // 此时map就是不可变对象了，修改会报错
        map.put(1, 3);
        log.info("{}", map.get(1));
    }
}
```

我们来看看是如何将map转换为不可变对象的，源码如下：

```java
/**
 * Returns an <a href="Collection.html#unmodview">unmodifiable view</a> of the
 * specified map. Query operations on the returned map "read through"
 * to the specified map, and attempts to modify the returned
 * map, whether direct or via its collection views, result in an
 * {@code UnsupportedOperationException}.<p>
 *
 * The returned map will be serializable if the specified map
 * is serializable.
 *
 * @param <K> the class of the map keys
 * @param <V> the class of the map values
 * @param  m the map for which an unmodifiable view is to be returned.
 * @return an unmodifiable view of the specified map.
 */
public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m) {
    return new UnmodifiableMap<>(m);
}

/**
 * @serial include
 */
private static class UnmodifiableMap<K,V> implements Map<K,V>, Serializable {
    private static final long serialVersionUID = -1034234728574286014L;

    private final Map<? extends K, ? extends V> m;

    UnmodifiableMap(Map<? extends K, ? extends V> m) {
        if (m==null)
            throw new NullPointerException();
        this.m = m;
    }    

    public int size()                        {return m.size();}
    public boolean isEmpty()                 {return m.isEmpty();}
    public boolean containsKey(Object key)   {return m.containsKey(key);}
    public boolean containsValue(Object val) {return m.containsValue(val);}
    public V get(Object key)                 {return m.get(key);}

    public V put(K key, V value) {
        throw new UnsupportedOperationException();
    }
    public V remove(Object key) {
        throw new UnsupportedOperationException();
    }        
...    
```

可以看到，实际上unmodifiableMap方法里是返回了一个内部类UnmodifiableMap的实例。而这个UnmodifiableMap类实现了Map接口，并且在构造器中将我们传入的map对象赋值到了final修饰的属性m中。在该类中除了一些“查询”方法，其他涉及到修改的方法都会抛出UnsupportedOperationException异常，这样外部就无法修改该对象内的数据。我们在调用涉及到修改数据的方法都会报错，这样就实现了将一个可变对象转换成一个不可变的对象。

除了以上示例中所使用的unmodifiableMap方法外，还有许多转换不可变对象的方法，如下：

![Unmodifiable](images/Chapter04SafePublishObj/UnmodifiableXXX.png)

然后我们再来看看Guava中创建不可变对象的方法，示例代码如下

