# 第04章 安全发布对象

## 4.1 发布与逸出

### 发布对象

> 使一个对象能够被当前范围之外地代码所使用，例如通过方法返回对象的引用，或者通过公有的静态变量发布对象

### 对象逸出

> 一种错误的发布，当一个对象还没有构造完成时，就使它被其他线程所见

### 不争取的发布可变对象导致的两种错误

+ 1.发布线程以外的所有线程都可以看到被发布对象的过期的值
+ 2.线程看到的被发布对象的引用是最新的，然而被发布对象的状态却是过期地

### 不安全的发布示例

```java
package com.huawei.l00379880.mythread.Chapter04SecureObject.Section01PublishEscape;

import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;

/***********************************************************
 * @note      : 不安全的对象发布示例
 * @author    : l00379880 梁山广
 * @version   : V1.0 at 2019/8/29 16:59
 ***********************************************************/
@Slf4j
public class UnSafePublish {
    private String[] states = {"a", "b", "c"};

    /**
     * 外部通过这个函数拿到了states函数后可以直接基于引用修改对象了
     * 这样发布的对象是不安全的，因为我们无法得知其他线程是否会修改这个域导致该类里数据的错误
     *
     * @return states数组引用
     */
    public String[] getStates() {
        return states;
    }

    public static void main(String[] args) {
        UnSafePublish unSafePublish = new UnSafePublish();
        // 输出[a, b, c]
        System.out.println(Arrays.toString(unSafePublish.getStates()));

        // 只用get就实现了修改states的效果，显然unSafePublish是不安全的对象
        unSafePublish.getStates()[0]="d";
        // 输出[d, b, c]
        System.out.println(Arrays.toString(unSafePublish.getStates()));
    }
}
```

在这个例子中，我们通过new对象得到了对象实例。获得这个对象后，我们可以调用getStates()方法得到私有属性的引用，这样就可以在其他任何线程中，修改该属性的值。那么这就会导致我们在其他线程中，获取该属性的值时是不确定的，因为并不能得知该属性的值是否已被其他线程所修改过，所以这就是不安全的对象发布。

### 对象逸出示例

