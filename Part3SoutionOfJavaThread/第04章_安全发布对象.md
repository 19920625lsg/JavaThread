# 第04章 安全发布对象

## 4.1 发布与逸出

### 发布对象

> 使一个对象能够被当前范围之外地代码所使用，例如通过方法返回对象的引用，或者通过公有的静态变量发布对象

### 对象逸出

> 一种错误的发布，当一个对象还没有构造完成时，就使它被其他线程所见

### 不争取的发布可变对象导致的两种错误

+ 1.发布线程以外的所有线程都可以看到被发布对象的过期的值
+ 2.线程看到的被发布对象的引用是最新的，然而被发布对象的状态却是过期地

### 不安全的发布示例

```java
package com.huawei.l00379880.mythread.Chapter04SecureObject.Section01PublishEscape;

import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;

/***********************************************************
 * @note      : 不安全的对象发布示例
 * @author    : l00379880 梁山广
 * @version   : V1.0 at 2019/8/29 16:59
 ***********************************************************/
@Slf4j
public class UnSafePublish {
    private String[] states = {"a", "b", "c"};

    /**
     * 外部通过这个函数拿到了states函数后可以直接基于引用修改对象了
     * 这样发布的对象是不安全的，因为我们无法得知其他线程是否会修改这个域导致该类里数据的错误
     *
     * @return states数组引用
     */
    public String[] getStates() {
        return states;
    }

    public static void main(String[] args) {
        UnSafePublish unSafePublish = new UnSafePublish();
        // 输出[a, b, c]
        System.out.println(Arrays.toString(unSafePublish.getStates()));

        // 只用get就实现了修改states的效果，显然unSafePublish是不安全的对象
        unSafePublish.getStates()[0]="d";
        // 输出[d, b, c]
        System.out.println(Arrays.toString(unSafePublish.getStates()));
    }
}
```

在这个例子中，我们通过new对象得到了对象实例。获得这个对象后，我们可以调用getStates()方法得到私有属性的引用，这样就可以在其他任何线程中，修改该属性的值。那么这就会导致我们在其他线程中，获取该属性的值时是不确定的，因为并不能得知该属性的值是否已被其他线程所修改过，所以这就是不安全的对象发布。

### 对象逸出示例

```java
package com.huawei.l00379880.mythread.Chapter04SecureObject.Section01PublishEscape;

/***********************************************************
 * @note      : 对象逸出示例，在对象构造完成前，不可以将其发布
 * @author    : l00379880 梁山广
 * @version   : V1.0 at 2019/8/29 17:30
 ***********************************************************/

public class Escape {
    private int thisCanEscape=0;
    public Escape() {
        new InnerClass();
    }

    private class InnerClass{
        public InnerClass(){
            System.out.println(Escape.this.thisCanEscape);
        }
    }

    public static void main(String[] args) {
        new Escape();
    }
}
```

在以上这个例子中，内部类的构造器里包含了对封装实例的隐含引用，这样在对象没有被正确构造完成之前就会被发布，由此会导致不安全的因素在里面。其中一个就是导致this引用在构造期间逸出的错误，它是在构造函数构造过程中启动了一个线程，无论是显式启动还是隐式启动，都会造成this引用的逸出。新线程总会在所属对象构造完毕之前就已经看到它了，所以如果要在构造函数中创建线程，那么不要启动它，而是应该采用一个专有的start，或是其他初始化的方式统一启动线程。这里其实我们可以使用工厂方法和私有构造函数来完成对象创建和监听器的注册等等来避免不正确的发布。

## 4.2~4.3 安全发布对象的四种方法

上一小节中，我们简述了什么是发布对象，以及给出了不安全发布对象的示例和对象逸出的示例和说明。所以本小节我们将看看如何安全的发布对象，想要安全的发布对象主要有四种方法：

+ 在静态初始化函数中初始化一个对象的引用
+ 将对象的引用保存到volatile类型域或者AtomicReference对象中
+ 将对象的引用保存到某个正确构造对象的final类型域中
+ 将对象的引用保存到一个由锁保护的域中

以上所提到的几种方法都可以应用到单例模式中，所以本文将以单例模式为例，介绍如何安全发布对象，以及单例实现的一些问题。

众所周知，单例模式是最常用的设计模式了。Spring容器中所管理的类的实例默认也是单例的，虽然单例看似简单，但也是有不少需要注意的地方，特别是在多线程环境下。基础的单例模式实现方式就不赘述了，我们来看看为什么采用了双重同步锁的懒汉式单例还是线程不安全的。示例代码如下：
